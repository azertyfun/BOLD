; *************************
; Project: BOLD
; File: loader.dasm
; *************************

; =================
; Load built-in
; programs
; =================

:load
	set B, str_loading
	set I, 0x8160
	jsr write
	
	set I, 0
	
	set A, [selected]
	set Y, ptr_programs
	add Y, A
	set Y, [Y]

	set Z, ptr_endPrograms
	add Z, A
	set Z, [Z]
		
	set PC, 0xE000
	
	
:loader
	:loader_loop0
		sti [I], [Y]
		add Y, 1
		ifn Y, Z
			set PC, 0xE000 ;Let's go back to the loop (can't use loader_loop0 because the address changes while copying lodaer)
	;Clearing RAM until reaching this
	:loader_loop1
		set [Z], 0
		add Z, 1
		ifn Z, 0xDFFF
			sub PC, 4 ;Let's go back to loader_loop1
	
	set A, 0
	set B, 0
	set C, 0
	set X, 0
	set Y, 0
	set Z, 0
	set I, 0
	set J, 0
	set EX, 0
	
	set PC, 0
:loader_end


; =================
; Load from floppy  
; =================
; First sector of the floppy must contain infos for BOLD :
;
; The two first words must be 0x9876, 0x5432. That means that this is a BOLD-compatible OS.
; Third word must be the number of sectors the program takes (without this first sector). Must be max 32 sectors.
; Then 10 reserved words.
; Words from 14 to 30 contains the name of the program (16 chars, fill with spaces). Not used yet.

:loadFLoppy
	;Checking disk drive
	ife [floppyDrive], 0 ;If no disk drive connected
		set B, str_noDrive
	ife B, str_noDrive
		set PC, loadFloppy_err
	set A, 0
	hwi [floppyDrive] ;If no floppy in the drive (STATE_NO_MEDIA)
	ife B, 0x0
		set B, str_noFloppy
	ife B, str_noFloppy
		set PC, loadFloppy_err
		
	;Reading first sector at 0x9000
	set A, 2
	set X, 0
	set Y, 0x9000
	hwi [floppyDrive]
	ifn B, 1
		set B, str_noReadPossible ;If reading not possible, reboot
	ife B, str_noReadPossible
		set PC, loadFloppy_err
	
	;Waiting for the read to finish
	:loadFloppy_waitReadFinish
	set A, 0
	hwi [floppyDrive]
	ife B, 0x0003 ;If STATE_BUSY
		set PC, loadFloppy_waitReadFinish
		
	ifn [0x9000], 0x9876
		set B, str_invalid
	ifn [0x9001], 0x5432
		set B, str_invalid
	ife B, str_invalid
		set PC, loadFloppy_err
	
	;If BOLD-compatible drive
	set X, 0 ;Will be 1 after entered the loop
	set J, 0 ;Number of sectors read
	
	:loadFloppy_loop0
		add X, 1

		set A, 0x0002 ;Read sectors
		STI Y, J ;We want to read at 0xA000 + number of sectors read
		mul Y, 0x200
		add Y, 0xA000
		hwi [floppyDrive]
		
		;If error happened, displaying error text and rebooting
		ifn B, 1
			set B, str_noReadPossible
		ife B, str_noReadPossible
			set PC, loadFloppy_err
		
		set A, 0
		:loadFloppy_loop1
			hwi [floppyDrive]
			ife B, 0x0003 ;If STATE_BUSY
			set PC, loadFloppy_loop1
		
		ifn X, [0x9002] ;If not read all the sectors
			set PC, loadFloppy_loop0
	
	;We have loaded X sectors at 0xA000 ! We can load the program into the memory
	set B, str_loading
	set I, 0x8160
	jsr write
	
	set I, 0
	
	set Y, 0xA000
	
	set Z, [0x9002] ;Number of sectors the program takes
	mul Z, 0x200
	add Z, 0xA000
		
	set PC, 0xE000 ;We can now load the program !
	
; ====================
; B : Pointer to the err string
; ====================
:loadFloppy_err
	set I, 0x8160
	jsr write
	
	set A, 0
	hwi [keyboard] ;Clears keyboard buffer
		
	;Waiting for user to type a letter
	set A, 1
	:loadFloppy_err_loop0
	hwi [keyboard]
	ife C, 0
		set PC, loadFloppy_err_loop0
	
	set PC, 0

:str_loading DAT "Loading program.                ", 0
:str_noDrive DAT "No floppy drive detected !      ", 0
:str_noFloppy DAT "No floppy into the media drive !", 0
:str_noReadPossible DAT "Impossible to read from floppy !", 0
:str_invalid DAT "Not compatible floppy !         ", 0